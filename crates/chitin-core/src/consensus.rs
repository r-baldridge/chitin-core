// crates/chitin-core/src/consensus.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Metadata attached to a Polyp after consensus evaluation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusMetadata {
    /// Epoch in which this Polyp was evaluated.
    pub epoch: u64,
    /// Aggregate score after Yuma-Semantic Consensus.
    pub final_score: f64,
    /// Individual validator scores.
    pub validator_scores: Vec<ValidatorScore>,
    /// Whether this Polyp passed the hardening threshold.
    pub hardened: bool,
    /// Timestamp of consensus finalization.
    pub finalized_at: DateTime<Utc>,
}

/// A single validator's score for a Polyp.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatorScore {
    /// The validator (Tide Node) that submitted this score.
    pub validator: [u8; 32], // hotkey
    /// Multi-dimensional Polyp quality scores.
    pub scores: PolypScores,
    /// Validator's stake at time of scoring (for weight computation).
    pub stake_at_scoring: u64,
    /// Signature over the score payload.
    pub signature: Vec<u8>,
}

/// Multi-dimensional quality scores for a Polyp.
///
/// Each dimension is scored 0.0 to 1.0.
/// The final score is a weighted combination of all dimensions.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolypScores {
    /// Did the ZK proof verify? Binary: 0.0 or 1.0.
    /// A score of 0.0 here causes immediate rejection regardless of other scores.
    pub zk_validity: f64,
    /// Semantic quality: coherence, informativeness, relevance.
    /// Evaluated by running the text through a quality classifier.
    pub semantic_quality: f64,
    /// Novelty: how much new information does this Polyp add?
    /// Measured by distance from nearest existing hardened Polyps.
    pub novelty: f64,
    /// Source credibility: reputation of the creator + quality of source attribution.
    pub source_credibility: f64,
    /// Embedding quality: cosine similarity between the vector and a reference
    /// embedding generated by the validator's own model instance.
    pub embedding_quality: f64,
}

impl PolypScores {
    /// Default dimension weights for computing final score.
    pub const DEFAULT_WEIGHTS: [f64; 5] = [0.30, 0.25, 0.15, 0.15, 0.15];

    /// Compute weighted final score.
    pub fn weighted_score(&self) -> f64 {
        let vals = [
            self.zk_validity,
            self.semantic_quality,
            self.novelty,
            self.source_credibility,
            self.embedding_quality,
        ];
        vals.iter()
            .zip(Self::DEFAULT_WEIGHTS.iter())
            .map(|(v, w)| v * w)
            .sum()
    }
}

/// Validator attestation for a hardened Polyp.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attestation {
    /// Validator hotkey that signed.
    pub validator: [u8; 32],
    /// Epoch of attestation.
    pub epoch: u64,
    /// The Polyp ID being attested.
    pub polyp_id: Uuid,
    /// The CID of the hardened Polyp on IPFS.
    pub cid: String,
    /// ed25519 signature over (polyp_id || cid || epoch).
    pub signature: Vec<u8>,
}

/// Lineage information for a hardened Polyp.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HardeningLineage {
    /// IPFS CID of the hardened Polyp.
    pub cid: String,
    /// Merkle proof linking this Polyp to the epoch Merkle root.
    pub merkle_proof: Vec<[u8; 32]>,
    /// Epoch Merkle root.
    pub merkle_root: [u8; 32],
    /// Validator attestations.
    pub attestations: Vec<Attestation>,
    /// On-chain transaction hash anchoring the Merkle root (if applicable).
    pub anchor_tx: Option<String>,
    /// Timestamp of hardening.
    pub hardened_at: DateTime<Utc>,
}
