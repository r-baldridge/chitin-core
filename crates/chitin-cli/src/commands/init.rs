// crates/chitin-cli/src/commands/init.rs
//
// `chitin init` â€” scaffold the default configuration directory and files.

use chitin_core::crypto::Keypair;
use std::fs;
use std::path::PathBuf;

/// Run the `chitin init` command.
///
/// Creates the default config directory (~/.chitin/), writes a default config.toml,
/// and generates an initial ed25519 keypair.
pub async fn run() -> Result<(), Box<dyn std::error::Error>> {
    let config_dir = get_config_dir()?;

    // Create config directory if it does not exist.
    if !config_dir.exists() {
        fs::create_dir_all(&config_dir)?;
        println!("Created config directory: {}", config_dir.display());
    } else {
        println!("Config directory already exists: {}", config_dir.display());
    }

    // Write default config.toml.
    let config_path = config_dir.join("config.toml");
    if !config_path.exists() {
        let default_config = r#"# Chitin Protocol Configuration
# Generated by `chitin init`

node_type = "hybrid"
data_dir = "~/.chitin/data"
rpc_host = "127.0.0.1"
rpc_port = 50051
p2p_port = 4001
ipfs_api_url = "http://127.0.0.1:5001"
log_level = "info"
"#;
        fs::write(&config_path, default_config)?;
        println!("Wrote default config: {}", config_path.display());
    } else {
        println!("Config already exists: {}", config_path.display());
    }

    // Generate initial keypair.
    let keys_dir = config_dir.join("keys");
    if !keys_dir.exists() {
        fs::create_dir_all(&keys_dir)?;
    }

    let hotkey_path = keys_dir.join("hotkey.pub");
    if !hotkey_path.exists() {
        let keypair = Keypair::generate();
        let pubkey = keypair.public_key_bytes();
        let pubkey_hex = hex_encode(&pubkey);

        // Save public key as hex.
        fs::write(&hotkey_path, &pubkey_hex)?;

        // Save signing key bytes (for Phase 1 simplicity; real impl would use encrypted keystore).
        let signing_key_bytes = keypair.signing_key.to_bytes();
        let secret_path = keys_dir.join("hotkey.secret");
        fs::write(&secret_path, hex_encode(&signing_key_bytes))?;

        println!("Generated keypair:");
        println!("  Public key: {}", pubkey_hex);
        println!("  Saved to:   {}", hotkey_path.display());
    } else {
        println!("Keypair already exists: {}", hotkey_path.display());
    }

    println!();
    println!("Chitin Protocol initialized successfully.");
    println!("Run `chitin status` to check node connectivity.");

    Ok(())
}

/// Get the config directory path (~/.chitin/).
fn get_config_dir() -> Result<PathBuf, Box<dyn std::error::Error>> {
    let home = dirs::home_dir().ok_or("Could not determine home directory")?;
    Ok(home.join(".chitin"))
}

/// Encode bytes as a hex string.
fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}
