// crates/chitin-cli/src/commands/init.rs
//
// `chitin init` — scaffold the default configuration directory and files.

use chitin_core::crypto::Keypair;
use chitin_core::identity::NodeIdentity;
use std::fs;
use std::path::PathBuf;

/// Run the `chitin init` command.
///
/// Creates the default config directory (~/.chitin/), writes a default config.toml,
/// and generates an initial ed25519 keypair.
pub async fn run() -> Result<(), Box<dyn std::error::Error>> {
    let config_dir = get_config_dir()?;

    // Create config directory if it does not exist.
    if !config_dir.exists() {
        fs::create_dir_all(&config_dir)?;
        println!("Created config directory: {}", config_dir.display());
    } else {
        println!("Config directory already exists: {}", config_dir.display());
    }

    // Write default config.toml.
    let config_path = config_dir.join("config.toml");
    if !config_path.exists() {
        let default_config = r#"# Chitin Protocol Configuration
# Generated by `chitin init`

node_type = "hybrid"
data_dir = "~/.chitin/data"
rpc_host = "127.0.0.1"
rpc_port = 50051
p2p_port = 4001
ipfs_api_url = "http://127.0.0.1:5001"
log_level = "info"

# --- Peer Networking (HTTP Relay) ---
# Uncomment and configure to enable multi-node peer networking.
#
# This node's publicly reachable URL (other nodes will use this to reach us):
# self_url = "http://YOUR_PUBLIC_IP:50051"
#
# List of peer node URLs to connect to:
# peers = ["http://PEER1_IP:50051", "http://PEER2_IP:50051"]
"#;
        fs::write(&config_path, default_config)?;
        println!("Wrote default config: {}", config_path.display());
    } else {
        println!("Config already exists: {}", config_path.display());
    }

    // Generate initial keypair.
    let keys_dir = config_dir.join("keys");
    if !keys_dir.exists() {
        fs::create_dir_all(&keys_dir)?;
    }

    // Generate hotkey (operational key).
    let hotkey_path = keys_dir.join("hotkey.pub");
    if !hotkey_path.exists() {
        let keypair = Keypair::generate();
        let pubkey = keypair.public_key_bytes();
        let pubkey_hex = hex_encode(&pubkey);

        // Save public key as hex.
        fs::write(&hotkey_path, &pubkey_hex)?;

        // Save signing key bytes (for Phase 1 simplicity; real impl would use encrypted keystore).
        let signing_key_bytes = keypair.signing_key.to_bytes();
        let secret_path = keys_dir.join("hotkey.secret");
        fs::write(&secret_path, hex_encode(&signing_key_bytes))?;

        println!("Generated hotkey:");
        println!("  Public key: {}", pubkey_hex);
        println!("  Saved to:   {}", hotkey_path.display());
    } else {
        println!("Hotkey already exists: {}", hotkey_path.display());
    }

    // Generate coldkey (long-term identity key).
    let coldkey_pub_path = keys_dir.join("coldkey.pub");
    if !coldkey_pub_path.exists() {
        let coldkey_pair = Keypair::generate();
        let coldkey_pub = coldkey_pair.public_key_bytes();
        let coldkey_pub_hex = hex_encode(&coldkey_pub);

        // Save coldkey public key as hex.
        fs::write(&coldkey_pub_path, &coldkey_pub_hex)?;

        // Save coldkey secret key as hex.
        let coldkey_secret_bytes = coldkey_pair.signing_key.to_bytes();
        let coldkey_secret_path = keys_dir.join("coldkey.secret");
        fs::write(&coldkey_secret_path, hex_encode(&coldkey_secret_bytes))?;

        // Derive and display the DID.
        let did = NodeIdentity::derive_did(&coldkey_pub);

        println!("Generated coldkey:");
        println!("  Public key: {}", coldkey_pub_hex);
        println!("  DID:        {}", did);
        println!("  Saved to:   {}", coldkey_pub_path.display());
        println!("  IMPORTANT:  Back up coldkey.secret securely — it controls your node identity.");
    } else {
        // Read existing coldkey to display DID.
        if let Ok(hex_str) = fs::read_to_string(&coldkey_pub_path) {
            if let Some(bytes) = hex_decode_bytes(hex_str.trim()) {
                if bytes.len() == 32 {
                    let mut arr = [0u8; 32];
                    arr.copy_from_slice(&bytes);
                    let did = NodeIdentity::derive_did(&arr);
                    println!("Coldkey already exists: {}", coldkey_pub_path.display());
                    println!("  DID: {}", did);
                } else {
                    println!("Coldkey already exists: {}", coldkey_pub_path.display());
                }
            } else {
                println!("Coldkey already exists: {}", coldkey_pub_path.display());
            }
        } else {
            println!("Coldkey already exists: {}", coldkey_pub_path.display());
        }
    }

    println!();
    println!("Chitin Protocol initialized successfully.");
    println!("Run `chitin status` to check node connectivity.");

    Ok(())
}

/// Get the config directory path (~/.chitin/).
fn get_config_dir() -> Result<PathBuf, Box<dyn std::error::Error>> {
    let home = dirs::home_dir().ok_or("Could not determine home directory")?;
    Ok(home.join(".chitin"))
}

/// Encode bytes as a hex string.
fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

/// Decode a hex string into bytes. Returns None if the string is invalid hex.
fn hex_decode_bytes(hex: &str) -> Option<Vec<u8>> {
    if hex.len() % 2 != 0 {
        return None;
    }
    (0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).ok())
        .collect()
}
